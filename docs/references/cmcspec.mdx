import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Cycles Minting Canister (CMC) API

<MarkdownChipRow labels={["Reference"]} />

## Overview

The Cycles Minting Canister (CMC) is a system canister on the Internet Computer responsible for converting ICP tokens into **cycles**. It supports:

- Topping up existing canisters
- Creating new canisters
- Depositing minted cycles into ledger-managed accounts
- Fetching exchange rates and subnet configuration

The CMC is governed entirely by the **NNS (Network Nervous System)** and receives configuration updates through proposals.

## Configuration Parameters

- **Conversion Rate Source**: The ICP/XDR exchange rate is **pushed** into the CMC by a dedicated *exchange rate canister*. This data reflects live market pricing and determines the ICP→cycles conversion.

- **Governance Control**: All operations of the CMC — including upgrades, configuration, and authorized callers — are managed through NNS proposals.


## API Endpoints

The CMC exposes a set of core methods for converting ICP into cycles and interacting with subnet configuration. These include:

- `notify_create_canister`: Processes an ICP payment by minting cycles and using them to create a new canister, assigning control to the specified principal and applying optional settings.
- `notify_top_up`: Processes an ICP payment by minting cycles and sending them to an existing canister to increase its available balance.
- `notify_mint_cycles`: Processes an ICP payment by minting cycles and depositing them into a cycles ledger account associated with a subaccount.
- `create_canister`: Creates a canister using cycles directly attached to the call.
- `get_icp_xdr_conversion_rate`: Returns the current ICP/XDR exchange rate with certification.
- `get_subnet_types_to_subnets`: Lists available subnets grouped by their types.
- `get_principals_authorized_to_create_canisters_to_subnets`: Indicates which principals are permitted to create canisters on which subnets.
- `get_default_subnets`: Returns the subnets for general-purpose canister creation.
- `get_build_metadata`: Displays internal version and build information for the CMC.


## API Reference

### `notify_create_canister`

Creates a new canister after verifying an ICP payment recorded in the ICP Ledger.
If the `subnet_selection field is omitted, the CMC will automatically choose a suitable subnet at random from the available options.

The CMC expects the payment to follow a strict structure that encodes both the **intent** and the **recipient**:

- The **destination account** of the ICP transfer must be the CMC's account with a subaccount derived from the intended controller's principal.
- The **memo field** must explicitly indicate the intent to create a canister. This can be expressed as:
  - A legacy 64-bit unsigned integer memo with value `0x41455243` (ASCII `"CREA"`)
  - Or, for ICRC-1-compatible transfers (e.g., `icrc1_transfer`, `icrc2_transfer_from`), a memo blob equal to:
    ```candid
    "\43\52\45\41\00\00\00\00"
    ```
    which represents `"CREA"` padded to 8 bytes.

- **Parameters:**
  ```candid
  record {
    block_index: nat64;              // The ledger block containing the ICP payment
    controller: principal;           // The principal who will control the new canister
    settings: opt CanisterSettings;  // Optional settings like controllers, memory limits, etc.
    subnet_type: opt text;           // Deprecated: legacy subnet selection
    subnet_selection: opt SubnetSelection; // Preferred subnet selection method
  }
  ```

- **Returns:**
  ```candid
  variant { Ok: principal; Err: NotifyError }
  ```

- **Notes:**
  - The call is idempotent with respect to `block_index`; repeating it returns the same result.
  - The controller must match the one encoded in the subaccount used for the payment.
  - Only transactions that follow the exact memo format will be processed successfully.


  ### `notify_top_up`

  Tops up an existing canister by minting cycles based on an ICP payment recorded in the ICP Ledger.

  The CMC expects the payment to follow a strict structure that encodes both the **intent** and the **target canister**:

  - The **destination account** of the ICP transfer must be the CMC's account with a subaccount derived from the target canister’s principal.
  - The **memo field** must explicitly indicate the intent to top up a canister. This can be expressed as:
    - A legacy 64-bit unsigned integer memo with value `0x50555054` (ASCII `"PUPT"`)
    - Or, for ICRC-1-compatible transfers (e.g., `icrc1_transfer`, `icrc2_transfer_from`), a memo blob equal to:
      ```candid
      "\50\55\50\54\00\00\00\00"
      ```
      which represents `"PUPT"` padded to 8 bytes.

  - **Parameters:**
    ```candid
    record {
      block_index: nat64;     // Block index of the ICP ledger payment
      canister_id: principal; // Canister to be topped up
    }
    ```

  - **Returns:**
    ```candid
    variant { Ok: nat; Err: NotifyError } // Number of cycles minted and sent
    ```

  - **Notes:**
    - The subaccount used in the transfer must be derived from the target canister’s principal using the standard 32-byte encoding (see “Shared Logic” section).
    - This method is idempotent by `block_index`: retrying the same request will return the same result if it already succeeded.
    - Only transfers matching the expected structure and memo will be accepted.

    ### `notify_mint_cycles`

    Mints cycles into a **cycles ledger account** based on an ICP payment recorded in the ICP Ledger.

    This method is used for depositing cycles into a ledger-managed subaccount, not directly into a canister. It supports minting only from **ICRC-1-compatible transfers**, and not from legacy `transfer` calls.

    The CMC expects the payment to follow a strict structure that encodes the **intent**:

    - The **destination account** of the ICP transfer must be the CMC's account with a subaccount matching the `to_subaccount` parameter.
    - The **memo field** must be an ICRC-1-style `blob`, and must equal:
      ```candid
       "\4d\49\4e\54\00\00\00\00"
      ```
      which represents `"MINT"` padded to 8 bytes (no legacy `u64` memo is accepted).

    - **Parameters:**
      ```candid
      record {
        block_index: nat64;         // Block index of the ICP ledger payment
        to_subaccount: opt blob;    // 32-byte subaccount to credit in the cycles ledger
        deposit_memo: opt blob;     // Optional application-specific memo
      }
      ```

    - **Returns:**
      ```candid
      variant {
        Ok: record {
          block_index: nat;  // Block index in the cycles ledger
          minted: nat;       // Amount of cycles minted
          balance: nat;      // Final balance of the cycles ledger account
        };
        Err: NotifyError;
      }
      ```

    - **Notes:**
      - Only authorized principals may call this method.
      - The `to_subaccount` must match the subaccount used in the ICP destination address.
      - Idempotent by `block_index`.
      - This method only processes transfers with a valid ICRC-1 memo and does not support legacy-style memos.


  ### `create_canister`

Creates a new canister using cycles attached directly to the call (not from an ICP ledger payment).

Unlike `notify_create_canister`, this method does not rely on an external ICP transaction. Instead, the calling canister must attach enough cycles to cover the creation cost.

- If `subnet_selection` is omitted, the CMC will select a suitable subnet at random from the available subnets.
- If `settings` is provided, it will override default configuration for the new canister.
- If no `settings` are given, the calling principal becomes the sole controller.

- **Parameters:**
  ```candid
  record {
    settings: opt CanisterSettings;         // Optional settings: controller(s), allocations, limits, etc.
    subnet_type: opt text;                  // (Deprecated) Legacy subnet type selection
    subnet_selection: opt SubnetSelection;  // Preferred way to select the subnet
  }
  ```

- **Returns:**
  ```candid
  variant { Ok: principal; Err: CreateCanisterError }
  ```

- **Notes:**
  - This method requires cycles to be attached to the call.
  - Returns the principal of the newly created canister.
  - The result is **not idempotent** — calling it again will consume cycles and create a different canister.
