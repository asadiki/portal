import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Cycles Minting Canister (CMC) API

<MarkdownChipRow labels={["Reference"]} />

## Overview

The Cycles Minting Canister (CMC) is a system canister on the Internet Computer responsible for converting ICP tokens into **cycles**. It supports:

- Topping up existing canisters
- Creating new canisters
- Depositing minted cycles into ledger-managed accounts
- Fetching exchange rates and subnet configuration

The CMC is governed entirely by the **NNS (Network Nervous System)** and receives configuration updates through proposals.

## Configuration Parameters

- **Conversion Rate Source**: The ICP/XDR exchange rate is **pushed** into the CMC by a dedicated *exchange rate canister*. This data reflects live market pricing and determines the ICP→cycles conversion.

- **Governance Control**: All operations of the CMC — including upgrades, configuration, and authorized callers — are managed through NNS proposals.


## API Endpoints

The CMC exposes a set of core methods for converting ICP into cycles and interacting with subnet configuration. These include:

- `notify_create_canister`: Processes an ICP payment by minting cycles and using them to create a new canister, assigning control to the specified principal and applying optional settings.
- `notify_top_up`: Processes an ICP payment by minting cycles and sending them to an existing canister to increase its available balance.
- `notify_mint_cycles`: Processes an ICP payment by minting cycles and depositing them into a cycles ledger account associated with a subaccount.
- `create_canister`: Creates a canister using cycles directly attached to the call.
- `get_icp_xdr_conversion_rate`: Returns the current ICP/XDR exchange rate with certification.
- `get_subnet_types_to_subnets`: Lists available subnets grouped by their types.
- `get_principals_authorized_to_create_canisters_to_subnets`: Indicates which principals are permitted to create canisters on which subnets.
- `get_default_subnets`: Returns the subnets for general-purpose canister creation.
- `get_build_metadata`: Displays internal version and build information for the CMC.


## API Reference

### `notify_create_canister`

Creates a new canister after verifying an ICP payment recorded in the ICP Ledger.
If the `subnet_selection field is omitted, the CMC will automatically choose a suitable subnet at random from the available options.

The CMC expects the payment to follow a strict structure that encodes both the **intent** and the **recipient**:

- The **destination account** of the ICP transfer must be the CMC's account with a subaccount derived from the intended controller's principal.
- The **memo field** must explicitly indicate the intent to create a canister. This can be expressed as:
  - A legacy 64-bit unsigned integer memo with value `0x41455243` (ASCII `"CREA"`)
  - Or, for ICRC-1-compatible transfers (e.g., `icrc1_transfer`, `icrc2_transfer_from`), a memo blob equal to:
    ```candid
    "\43\52\45\41\00\00\00\00"
    ```
    which represents `"CREA"` padded to 8 bytes.

- **Parameters:**
  ```candid
  record {
    block_index: nat64;              // The ledger block containing the ICP payment
    controller: principal;           // The principal who will control the new canister
    settings: opt CanisterSettings;  // Optional settings like controllers, memory limits, etc.
    subnet_type: opt text;           // Deprecated: legacy subnet selection
    subnet_selection: opt SubnetSelection; // Preferred subnet selection method
  }
  ```

- **Returns:**
  ```candid
  variant { Ok: principal; Err: NotifyError }
  ```

- **Notes:**
  - The call is idempotent with respect to `block_index`; repeating it returns the same result.
  - The controller must match the one encoded in the subaccount used for the payment.
  - Only transactions that follow the exact memo format will be processed successfully.


  ## `notify_top_up`

  Tops up an existing canister by minting cycles based on an ICP payment recorded in the ICP Ledger.

  The CMC expects the payment to follow a strict structure that encodes both the **intent** and the **target canister**:

  - The **destination account** of the ICP transfer must be the CMC's account with a subaccount derived from the target canister’s principal.
  - The **memo field** must explicitly indicate the intent to top up a canister. This can be expressed as:
    - A legacy 64-bit unsigned integer memo with value `0x50555054` (ASCII `"PUPT"`)
    - Or, for ICRC-1-compatible transfers (e.g., `icrc1_transfer`, `icrc2_transfer_from`), a memo blob equal to:
      ```candid
      "\50\55\50\54\00\00\00\00"
      ```
      which represents `"PUPT"` padded to 8 bytes.

  - **Parameters:**
    ```candid
    record {
      block_index: nat64;     // Block index of the ICP ledger payment
      canister_id: principal; // Canister to be topped up
    }
    ```

  - **Returns:**
    ```candid
    variant { Ok: nat; Err: NotifyError } // Number of cycles minted and sent
    ```

  - **Notes:**
    - The subaccount used in the transfer must be derived from the target canister’s principal using the standard 32-byte encoding (see “Shared Logic” section).
    - This method is idempotent by `block_index`: retrying the same request will return the same result if it already succeeded.
    - Only transfers matching the expected structure and memo will be accepted.
